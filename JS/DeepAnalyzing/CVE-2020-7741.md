**Project**: Hello.js

**Version**: 1.18.4

**Vulnerability Type**: Cross-Site Scripting

**Vulnerability Description**: This affects the package hellojs before 1.18.6. The code get the param oauth_redirect from url and pass it to location.assign without any check and sanitisation. So we can simply pass some XSS payloads into the url param oauth_redirect, such as javascript:alert(1).

**Vulnerability Patch**: [fix(xss): oauth_redirect should be a valid url · MrSwitch/hello.js@d6f5137 (github.com)](https://github.com/MrSwitch/hello.js/commit/d6f5137f30de6e0ef7048191ee6ae575fdc2f669)

**Link to the vulnerable project**: [Release v1.18.4 · MrSwitch/hello.js (github.com)](https://github.com/MrSwitch/hello.js/releases/tag/v1.18.4)

**Tools**

No one of the tools in the arsenal is able to detect the vulnerability. 

**Patterns**:

1. [forEach in Nested Functions](https://github.com/GiuliCler/testability_tarpits/tree/main/JS/Testability_Patterns/23_forEach_in_nested)
2. [location.assign and location.search](https://github.com/GiuliCler/testability_tarpits/tree/main/JS/Testability_Patterns/82_location_assign_with_search)
3. [Too Function Calls](https://github.com/GiuliCler/testability_tarpits/tree/main/JS/Testability_Patterns/20_too_function_calls)

**Explain code**:

The source and the sink of the vulnerability are both in the file **src/hello.js**:

```js
//function responseHandler:
// OAuth and API response handler
responseHandler: function(window, parent) {
		var _this = this;
		var p;
    	//SOURCE OF VULNERABILITY
		var location = window.location; 

		// Is this an auth relay message which needs to call the proxy?
		p = _this.param(location.search);

		// OAuth2 or OAuth1 server response?
		if (p && p.state && (p.code || p.oauth_token)) {
			var state = JSON.parse(p.state);
			// Add this path as the redirect_uri
			p.redirect_uri = state.redirect_uri || location.href.replace(/[\?\#].*$/, '');
			// Redirect to the host
			var path = _this.qs(state.oauth_proxy, p);
            
            //function qs:
            qs: function(url, params, formatFunction) {
				if (params) {
					// Set default formatting function
					formatFunction = formatFunction || encodeURIComponent;
					// Override the items in the URL which already exist
					for (var x in params) {
						var str = '([\\?\\&])' + x + '=[^\\&]*';
						var reg = new RegExp(str);
						if (url.match(reg)) {
							url = url.replace(reg, '$1' + x + '=' + formatFunction(params[x]));
							delete params[x];
						}
					}
				}
				if (!this.isEmpty(params)) {
					return url + (url.indexOf('?') > -1 ? '&' : '?') + this.param(params, formatFunction);
				}
				return url;
			},
            
			//SINK OF VULNERABILITY
			location.assign(path);
			return;
		}

		// Save session, from redirected authentication
		// #access_token has come in?
		//
		// FACEBOOK is returning auth errors within as a query_string... thats a stickler for consistency.
		// SoundCloud is the state in the querystring and the token in the hashtag, so we'll mix the two together

		p = _this.merge(_this.param(location.search || ''), _this.param(location.hash || ''));

		// If p.state
		if (p && 'state' in p) {
			// Remove any addition information
			// E.g. p.state = 'facebook.page';
			try {
				var a = JSON.parse(p.state);
				_this.extend(p, a);
			}
			catch (e) {
				var stateDecoded = decodeURIComponent(p.state);
				try {
					var b = JSON.parse(stateDecoded);
					_this.extend(p, b);
				}
				catch (e) {
					console.error('Could not decode state parameter');
				}
			}
		}

		// OAuth redirect, fixes URI fragments from being lost in Safari
		// (URI Fragments within 302 Location URI are lost over HTTPS)
		// Loading the redirect.html before triggering the OAuth Flow seems to fix it.
		else if ('oauth_redirect' in p) {
			//SINK OF VULNERABILITY
			location.assign(decodeURIComponent(p.oauth_redirect));
			return;
		}
	}
```

**Refactoring**:

- **forEach in Nested Functions** (P24): forEach is transformed in a more explicit loop (in this example, a while loop). The transformation does not affect the semantic of the code (type **T1**). 

```js
// The piece of code following reported is about the function extend

// Before: 
Array.prototype.slice(args, 1).forEach(f$3);
function f$3(){
	if (Array.isArray(r) && Array.isArray(a)) {
         ...       
	}
}

// After:
var index = 1;
while(index < args.length()){
	if (Array.isArray(r) && Array.isArray(args[index])) {
        ...
    }
}
```

- **location.assign and location.search** (P82): a _document.write_ is added immediately after the _location.assign_ over the variable passed to the latter. The transformation changes the semantic of the code (type **T2**):

```js
// Before (code is reported with other tarpits already transformed):
var location = window.location;
var s = location.search;
...
location.assign(p.page_uri);

// After:
var location = window.location;
var s = location.search;
...
location.assign(p.page_uri);
document.write(p.page_uri);
```

- **Too Function Calls** (P21): The body of the function that is called is directly copied in that line of code and the arguments are assigned to new variables, coherently with the name used internally to the function. **T1** is the type of transformation:

```js
// Before:
var path = _this.qs(state.oauth_proxy, p);

// After:
/*qs*/
var path;
var url = state.oauth_proxy;
var params = p;
// qs body copied here
```

