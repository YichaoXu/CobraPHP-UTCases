**Project**: Angular Expressions

**Version**: 1.0.1

**Vulnerability Type**: Code Injection

**Vulnerability Description**: angular-expressions is "angular's nicest part extracted as a standalone module for the browser and node". In angular-expressions before version 1.1.2 there is a vulnerability which allows Remote Code Execution if you call "expressions.compile(userControlledInput)" where "userControlledInput" is text that comes from user input. The security of the package could be bypassed by using a more complex payload, using a ".constructor.constructor" technique. In terms of impact: If running angular-expressions in the browser, an attacker could run any browser script when the application code calls expressions.compile(userControlledInput). If running angular-expressions on the server, an attacker could run any Javascript expression, thus gaining Remote Code Execution. This is fixed in version 1.1.2 of angular-expressions. A temporary workaround might be either to disable user-controlled input that will be fed into angular-expressions in your application or allow only following characters in the userControlledInput.

**Vulnerability Patch**: [Fix Security Vulnerability by using hasOwnProperty defensively · peerigon/angular-expressions@07edb62 (github.com)](https://github.com/peerigon/angular-expressions/commit/07edb62902b1f6127b3dcc013da61c6316dd0bf1)

**Link to the vulnerable project**: [Release v1.0.1 · peerigon/angular-expressions (github.com)](https://github.com/peerigon/angular-expressions/releases/tag/v1.0.1)

**Tools**

No one of the tools in the arsenal is able to detect the vulnerability. 

**Patterns**:

1. [Modules](https://github.com/enferas/TestabilityTarpits/tree/main/JS/TestabilityPatterns/87_modules)
2. [Returned Function](https://github.com/enferas/TestabilityTarpits/tree/main/JS/TestabilityPatterns/36_returned_function)
4. [Type Juggling](https://github.com/enferas/TestabilityTarpits/tree/main/JS/TestabilityPatterns/86_type_juggling)
5. [Simple Array](https://github.com/enferas/TestabilityTarpits/tree/main/JS/TestabilityPatterns/90_simple_array)
6. [Functions in Object](https://github.com/enferas/TestabilityTarpits/tree/main/JS/TestabilityPatterns/75_functions_in_object)
7. [Too Function Calls](https://github.com/enferas/TestabilityTarpits/tree/main/JS/TestabilityPatterns/20_too_function_calls)

**Explain code**:

The vulnerability path is between the files **main.js** and **parse.js**

```js
function compile(src) {
	var cached;

	if (typeof src !== "string") {
		throw new TypeError(
			"src must be a string, instead saw '" + typeof src + "'"
		);
	}

	if (!compile.cache) {
		return parser.parse(src);
	}

	cached = compile.cache[src];
	if (!cached) {
		cached = compile.cache[src] = parser.parse(src);
	}

	return cached;
}

// the parse method is inside parse.js
Parser.prototype = {
	constructor: Parser,

	parse: function(text) {
		return this.astCompiler.compile(text);
	}
};

// where the compile function of astCompiler is defined as follow:
ASTCompiler.prototype = {
	compile: function(expression) {
		var self = this;
		var ast = this.astBuilder.ast(expression);
		this.state = {
			nextId: 0,
			filters: {},
			fn: { vars: [], body: [], own: {} },
			assign: { vars: [], body: [], own: {} },
			inputs: []
		};
		findConstantAndWatchExpressions(ast, self.$filter);
		var extra = "";
		var assignable;
		this.stage = "assign";
		if ((assignable = assignableAST(ast))) {
			this.state.computing = "assign";
			var result = this.nextId();
			this.recurse(assignable, result);
			this.return_(result);
			extra = "fn.assign=" + this.generateFunction("assign", "s,v,l");
		}
		var toWatch = getInputs(ast.body);
		self.stage = "inputs";
		forEach(toWatch, function(watch, key) {
			var fnKey = "fn" + key;
			self.state[fnKey] = { vars: [], body: [], own: {} };
			self.state.computing = fnKey;
			var intoId = self.nextId();
			self.recurse(watch, intoId);
			self.return_(intoId);
			self.state.inputs.push(fnKey);
			watch.watchId = key;
		});
		this.state.computing = "fn";
		this.stage = "main";
		this.recurse(ast);
		var fnString =
			// The build and minification steps remove the string "use strict" from the code, but this is done using a regex.
			// This is a workaround for this until we do a better job at only removing the prefix only when we should.
			'"' +
			this.USE +
			" " +
			this.STRICT +
			'";\n' +
			this.filterPrefix() +
			"var fn=" +
			this.generateFunction("fn", "s,l,a,i") +
			extra +
			this.watchFns() +
			"return fn;";
		// eslint-disable-next-line no-new-func
		var fn = new Function(
			"$filter",
			"getStringValue",
			"ifDefined",
			"plus",
			fnString
		)(this.$filter, getStringValue, ifDefined, plusFn);

		this.state = this.stage = undefined;
		fn.ast = ast;
		fn.literal = isLiteral(ast);
		fn.constant = isConstant(ast);
		return fn;
	},
    
//therefore at the end is returned a function that can be executed in this way:
evaluate = compile(input);
evaluate();
// this result in remote code execute since no sanitization is performed on the input
```

**Refactoring**:

- **Modules** (P87): the contents of imported JavaScript modules is copied where they are included. The transformation does not impact on the semantic of the code (**T1**).

```js
// Before:
var expressions = require("angular-expressions");

// After:
//var expressions = require("angular-expressions");
/* copy of the module angular-expressions here */
```

- **Returned Function** (P36): the function is declared in classic way and returned later in the code. The type of transformation is **T2** since it affects the code semantic.

```js
// Before:
return function(value, key) {
	iteratorFn(key, value);
};

// After:
function retfunc(value, key) {
	iteratorFn(key, value);
};
return retfunc;
```

- **Type Juggling** (P86): over-approximation that consists in considering a variable assignment after the loop. It impacts on the semantic of the code (type **T2**).

```js
// Before:
// in Lexer on parse.js file:
while (this.index < this.text.length) {
	var ch = this.text.charAt(this.index);
	if (ch === '"' || ch === "'") {
		this.readString(ch);
	} else if (
		this.isNumber(ch) ||
		(ch === "." && this.isNumber(this.peek()))
		) {
			this.readNumber();
		} else if (this.isIdentifierStart(this.peekMultichar())) {
			this.readIdent();
		} else if (this.is(ch, "(){}[].,;:?")) {
			this.tokens.push({ index: this.index, text: ch });
			this.index++;
		} else if (this.isWhitespace(ch)) {
			this.index++;
		} else {
			var ch2 = ch + this.peek();
			var ch3 = ch2 + this.peek(2);
			var op1 = OPERATORS[ch];
			var op2 = OPERATORS[ch2];
			var op3 = OPERATORS[ch3];
		if (op1 || op2 || op3) {
			var token = op3 ? ch3 : op2 ? ch2 : ch;
			this.tokens.push({ index: this.index, text: token, operator: true });
			this.index += token.length;
		} else {
			this.throwError(
				"Unexpected next character ",
				this.index,
				this.index + 1
			);
		}
	}
}

// After:
// over-approximation.
var to = thisText;
```

- **Simple Array** (P90): elements are directly assigned without add them through push method. It changes the semantic of the code (**T2**)

```js
// Before:
this.tokens.push({ index: this.index, text: token, operator: true });

// After:
this.tokens = { index: index, te: to$5, operator: true };
```

- **Functions in Object** (P75): the function is defined outside the object and a reference is maintained inside. Transformation is type **T2** since it changes the code semantic.

```js
// Before:
ASTCompiler.prototype = {
	compile: function(expression) {
        ...
        
// After:
ASTCompiler.prototype = {
	compile: compile1
	...
}
function compile1(expression){
    ...
}
```

- **Too Function Calls** (P21):  The body of the function that is called, is directly copied in that line of code and the arguments are assigned to new variables, coherently with the name used internally to the function. Transformation type is **T1** since it preserves the code semantic.

```js
// Before:
return parser.parse(src);

// After:
//return parser.parse(src);
text = src;
...
//body of parser.parse copied here
```

