**Project**: Docsify

**Version**: 4.11.3

**Vulnerability Type**: Cross-site Scripting (XSS)

**Vulnerability Description**: Docsify.js uses fragment identifiers (parameters after # sign) to load resources from server-side .md files. Due to lack of validation here, it is possible to provide external URLs after the /#/ (domain.com/#//attacker.com) and render arbitrary JavaScript/HTML inside docsify page.

**Vulnerability Patch**: [update: added html sanitizer for remote rendering by anikethsaha · Pull Request #1128 · docsifyjs/docsify (github.com)](https://github.com/docsifyjs/docsify/pull/1128)

**Link to the vulnerable project**: [Release v4.11.3 · docsifyjs/docsify (github.com)](https://github.com/docsifyjs/docsify/releases/tag/v4.11.3)

**Tools**:

No one of the tools in the arsenal is able to detect the vulnerability. 

**Patterns**:

1. [Modules](https://github.com/enferas/TestabilityTarpits/tree/main/JS/TestabilityPatterns/87_modules)
2. [Arrow Function](https://github.com/enferas/TestabilityTarpits/tree/main/JS/TestabilityPatterns/49_arrow_function)
3. [Inline Function](https://github.com/enferas/TestabilityTarpits/tree/main/JS/TestabilityPatterns/79_inline_function)
4. [Inheritance](https://github.com/enferas/TestabilityTarpits/tree/main/JS/TestabilityPatterns/55_inheritance)
5. [Callback Function](https://github.com/enferas/TestabilityTarpits/tree/main/JS/TestabilityPatterns/6_callback_function)
6. [Ajax GET Request](https://github.com/enferas/TestabilityTarpits/tree/main/JS/TestabilityPatterns/99_GET_ajax)
7. [Asynchronous Event Handler](https://github.com/enferas/TestabilityTarpits/tree/main/JS/TestabilityPatterns/78_asynchronous_event_handler)
8. [innertHTML-outerHTML](https://github.com/enferas/TestabilityTarpits/tree/main/JS/TestabilityPatterns/101_innerHTML_outerHTML)
9. [Too Function Calls](https://github.com/enferas/TestabilityTarpits/tree/main/JS/TestabilityPatterns/20_too_function_calls)

**Explain code**:

Two sinks have been considered: the first related to _xhr.send()_ in **src/core/fetch/ajax.js** and the second about the render of the external content in file **src/core/render/index.js**

```js
// (xhr)
// file: src/core/index.js 
ready(_ => new Docsify());
document.addEventListener('DOMContentLoaded', callback);
this._init(); // within callback, this is the Docsify object
initMixin(proto);
// file: src/core/init/index.js
initFetch(vm); // Fetch data
// file: src/core/fetch/index.js
(vm.$fetch(_ => callHook(vm, 'ready'));
this._fetch(() => {
        $resetEvents();
        done();
      }); //calling proto._fetch()
const req = request(file + qs, true, requestHeaders);
last = get(url, true, requestHeaders);
// file: src/core/fetch/ajax.js
xhr.send(); //first SINK

// (img => to vulnerability)
// file: src/core/index.js
ready(_ => new Docsify());
document.addEventListener('DOMContentLoaded', callback);
this._init();

// Async: EventListener.handleEvent

initMixin(proto);
//file: src/core/init/index.js 
initFetch(vm); // Fetch data
//file: src/core/fetch/index.js
vm.$fetch(_ => callHook(vm, 'ready'));
this._fetch(() => {
        $resetEvents();
        done();
      }); //calling proto._fetch()
this._loadSideAndNav(path, qs, loadSidebar, cb);
// file: src/core/fetch/ajax.js
on('load', ({ target }) => { ... })
xhr.addEventListener.apply(xhr, arguments);

// Async: EventListener.handleEvent

success(result.content, result.opt);
// file: src/core/fetch/index.js
this._renderMain(
          text,
          opt,
          this._loadSideAndNav(path, qs, loadSidebar, cb)
        ) //calling _renderMain
// file: src/core/render/index.js
callHook(this, 'beforeEach', text, result => { ... })
// file: src/core/init/lifecycle.js (in callHook method)
step(0);
step(index + 1);
next(data);
// file: src/core/render/index.js
prerenderEmbed( ... );
// file: src/core/render/embed.js
walkFetchEmbed({ compile, embedTokens, fetch }, ({ embedToken, token }) => { ... });
return cb({}); //inside function walkFetchEmbed
done(tokens); //in walkFetchEmbed
// file: src/core/render/index.js
callback(); //in function proto._renderMain
callHook(this, 'afterEach', html, text => renderMain.call(this, text));
// file: src/core/init/lifecycle.js in callHook method
next(data);
step(0);
// file: src/core/render/index.js
this._renderTo('.markdown-section', html);
node[replace ? 'outerHTML' : 'innerHTML'] = content; //second SINK
```

**Refactoring**:

- **Modules** (P87): The contents of imported JavaScript modules is copied where they are included. The transformation does not impact on the semantic of the code. The transformation preserves the code semantic and it is type **T1**.

```js
// Before;
import { merge, hyphenate, isPrimitive, hasOwn } from './util/core';

// After:
//import { merge, hyphenate, isPrimitive, hasOwn } from './util/core';
/* copy of the imported modules here */
```

- **Arrow Function** (P49): Function is transformed in Inline function. The transformation preserves the code semantic (**T1**).

```js
// Before:
text => renderMain.call(this, text)

// After:
function (text){ return renderMain.call(this, text) }
```

- **Inline Function** (P79): Inline function is rewritten as classic function. The transformation preserves the code semantic (type **T1**)

```js
// Before:
function (text){ return renderMain.call(this, text) }

// After:
function infunc(text){ 
    return renderMain.call(this, text) 
}
infunc(text);
```

- **Inheritance** (P55): child class is defined as simple class and the parent's methods are copied in its body and modified in accordance if they are override. The transformation preserves the code semantic (**T1**)

```js
// Before:
class History {
  constructor(config) {
    this.config = config;
  }

  getBasePath() {
    return this.config.basePath;
  }
    ...
class HashHistory extends History {
  constructor(config) {
    super(config);
    this.mode = 'hash';
  }
    
// After:
class HashHistory {
  constructor(config) {
    this.config = config;
    this.mode = 'hash';
  }
  getBasePath() {
    const path = window.location.pathname || '';
    const base = this.config.basePath;

    return /^(\/|https?:)/g.test(base) ? base : cleanPath(path + '/' + base);
  }
```

- **Callback Function** (P6): The callback function is directly called in the code without have been passed as argument. This transformation does not impact on the code semantic and therefore is type **T1**, but it is also type **T3** where the code dynamically loads external plugins.

```js
// Before: some tarpits have already been changed on this code example
function callback({ embedToken, token }){
    ... 
}
walkFetchEmbed({ compile, embedTokens, fetch }, callback);
function walkFetchEmbed({ embedTokens, compile, fetch }, cb) {
	...
    cb({ token, embedToken });
    ...
}
    
// After:
function callback({ embedToken, token }){
    ... 
}
walkFetchEmbed({ compile, embedTokens, fetch });
function walkFetchEmbed({ embedTokens, compile, fetch }) {
	...
    callback({ token, embedToken });
    ...
}
```

- **Ajax GET Request** (P99): to help tools to detect a GET request performed over a malicious URL, *document.write* of the variable (url) passed to the open GET request is performed. This changes code semantic and it is type **T2**.

```js
// Before:
xhr.open('GET', url);
...
xhr.send();

// After:
xhr.open('GET', url);
...
xhr.send();
document.write(url);
```

- **Asynchronous Event Handler** (P78): The event handler function is immediately called, while the link between function handler and the event (through addEventListener method) is commented. This transformation changes the semantic of the code (**T2**) since it avoids asynchronous behaviors.

```js
// Before:
document.addEventListener('DOMContentLoaded', callback);

// After
//document.addEventListener('DOMContentLoaded', callback);
callback();
```

- **InnerHTML - OuterHML** (P101): a *document.write* of the argument passed to *innerHTML* and _outerHTML_ assignment is written immediately after that line of code. This transformation changes the semantic of the code (**T2**).

```js
// Before:
node['outerHTML'] = content;
...
node['innerHTML'] = content;

// After:
node['outerHTML'] = content;
document.write(node['outerHTML']);
...
node['innerHTML'] = content;
document.write(node['innerHTML']);
```

- **Too Function Calls** (P21): The body of the function that is called is directly copied in that line of code and the arguments are assigned to new variables, coherently with the name used internally to the function. The type transformation is **T1** since it does not change the code semantic

```js
// Before:
done(tokens);

// After:
//done(tokens);
/* copy of the done function body here */
var tokens = tokens
```

The tarpits transformations have been applied to all the project code. Once the modified version has been submitted to Comm_1, the CVE vulnerability has been identified, while a [new one]([CVE - CVE-2021-23342 (mitre.org)](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-23342)) occurred:

```js
// until here the source is the same of the analyzed CVE
...
// file: src/core/render/index.js
next();
// file: src/core/fetch/index.js
loadNested(path, qs, loadSidebar, fn, this, true);
// file: src/core/fetch/ajax.js
xhr.send();

//then the path to the sink is the same of the analyzed CVE
```

